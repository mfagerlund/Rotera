// Generated by GradientScript from point-to-plane-distance.gs
// âœ“ 36 gradients verified
//
// Point to plane distance residual for coplanar constraints.
// Given 3 points (a, b, c) defining a plane and a test point (p),
// compute the signed distance from p to the plane.
//
// For N coplanar points, use this function (N-3) times:
//   - a, b, c = first 3 points (define the plane)
//   - p = each additional point (4th, 5th, ..., Nth)

export interface Point3D {
  x: number;
  y: number;
  z: number;
}

export interface PointToPlaneDistanceGradResult {
  value: number;
  da: Point3D;
  db: Point3D;
  dc: Point3D;
  dp: Point3D;
}

export function point_to_plane_distance(a: Point3D, b: Point3D, c: Point3D, p: Point3D): number {
  const e1x = b.x - a.x;
  const e1y = b.y - a.y;
  const e1z = b.z - a.z;
  const e2x = c.x - a.x;
  const e2y = c.y - a.y;
  const e2z = c.z - a.z;
  const nx = e1y * e2z - e1z * e2y;
  const ny = e1z * e2x - e1x * e2z;
  const nz = e1x * e2y - e1y * e2x;
  const vx = p.x - a.x;
  const vy = p.y - a.y;
  const vz = p.z - a.z;
  const dot = vx * nx + vy * ny + vz * nz;
  const normalLen = Math.sqrt(nx * nx + ny * ny + nz * nz + 1e-7);
  return dot / normalLen;
}

export function point_to_plane_distance_grad(a: Point3D, b: Point3D, c: Point3D, p: Point3D): PointToPlaneDistanceGradResult {
  const e1x = b.x - a.x;
  const e1y = b.y - a.y;
  const e1z = b.z - a.z;
  const e2x = c.x - a.x;
  const e2y = c.y - a.y;
  const e2z = c.z - a.z;
  const nx = e1y * e2z - e1z * e2y;
  const ny = e1z * e2x - e1x * e2z;
  const nz = e1x * e2y - e1y * e2x;
  const vx = p.x - a.x;
  const vy = p.y - a.y;
  const vz = p.z - a.z;
  const dot = vx * nx + vy * ny + vz * nz;
  const normalLen = Math.sqrt(nx * nx + ny * ny + nz * nz + 1e-7);
  const value = dot / normalLen;

  // Gradients
  const _tmp0 = e1y - e2y;
  const _tmp2 = 1 / (2 * normalLen);
  const _tmp4 = 1 / (normalLen * normalLen);
  const _tmp7 = e1z - e2z;
  const _tmp9 = e1x - e2x;

  // Gradient for a (first point of plane)
  const da: Point3D = {
    x: ((vz * _tmp0 - nx + vy * (-_tmp7)) * normalLen - dot * 2 * ((-_tmp7) * ny + _tmp0 * nz) * _tmp2) * _tmp4,
    y: ((vz * (-_tmp9) - ny + vx * _tmp7) * normalLen - dot * 2 * (_tmp7 * nx + (-_tmp9) * nz) * _tmp2) * _tmp4,
    z: ((vx * (-_tmp0) - nz + vy * _tmp9) * normalLen - dot * 2 * ((-_tmp0) * nx + _tmp9 * ny) * _tmp2) * _tmp4,
  };

  // Gradient for b (second point of plane)
  const db: Point3D = {
    x: ((vz * e2y - vy * e2z) * normalLen - dot * 2 * (e2y * nz - e2z * ny) * _tmp2) * _tmp4,
    y: ((vx * e2z - vz * e2x) * normalLen - dot * 2 * (e2z * nx - e2x * nz) * _tmp2) * _tmp4,
    z: ((vy * e2x - vx * e2y) * normalLen - dot * 2 * (e2x * ny - e2y * nx) * _tmp2) * _tmp4,
  };

  // Gradient for c (third point of plane)
  const dc: Point3D = {
    x: ((vy * e1z - vz * e1y) * normalLen - dot * 2 * (e1z * ny - e1y * nz) * _tmp2) * _tmp4,
    y: ((vz * e1x - vx * e1z) * normalLen - dot * 2 * (e1x * nz - e1z * nx) * _tmp2) * _tmp4,
    z: ((vx * e1y - vy * e1x) * normalLen - dot * 2 * (e1y * nx - e1x * ny) * _tmp2) * _tmp4,
  };

  // Gradient for p (test point)
  const dp: Point3D = {
    x: nx * normalLen * _tmp4,
    y: ny * normalLen * _tmp4,
    z: nz * normalLen * _tmp4,
  };

  return { value, da, db, dc, dp };
}
