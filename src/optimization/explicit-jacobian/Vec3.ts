/**
 * Vec3 - Simple 3D vector class for explicit gradient computations
 *
 * This is a plain number-based implementation (no automatic differentiation).
 * Used with hand-coded Jacobians generated by gradient-script.
 */

export class Vec3 {
  constructor(
    public readonly x: number,
    public readonly y: number,
    public readonly z: number
  ) {}

  // Static constructors
  static zero(): Vec3 {
    return new Vec3(0, 0, 0);
  }

  static one(): Vec3 {
    return new Vec3(1, 1, 1);
  }

  static fromArray(arr: [number, number, number]): Vec3 {
    return new Vec3(arr[0], arr[1], arr[2]);
  }

  // Basic operations
  add(other: Vec3): Vec3 {
    return new Vec3(this.x + other.x, this.y + other.y, this.z + other.z);
  }

  sub(other: Vec3): Vec3 {
    return new Vec3(this.x - other.x, this.y - other.y, this.z - other.z);
  }

  scale(s: number): Vec3 {
    return new Vec3(this.x * s, this.y * s, this.z * s);
  }

  neg(): Vec3 {
    return new Vec3(-this.x, -this.y, -this.z);
  }

  // Dot product
  dot(other: Vec3): number {
    return this.x * other.x + this.y * other.y + this.z * other.z;
  }

  // Cross product
  cross(other: Vec3): Vec3 {
    return new Vec3(
      this.y * other.z - this.z * other.y,
      this.z * other.x - this.x * other.z,
      this.x * other.y - this.y * other.x
    );
  }

  // Squared magnitude (avoids sqrt)
  sqrMagnitude(): number {
    return this.x * this.x + this.y * this.y + this.z * this.z;
  }

  // Magnitude
  magnitude(): number {
    return Math.sqrt(this.sqrMagnitude());
  }

  // Normalize
  normalize(): Vec3 {
    const mag = this.magnitude();
    if (mag < 1e-10) return Vec3.zero();
    return this.scale(1 / mag);
  }

  // Component-wise operations
  componentMul(other: Vec3): Vec3 {
    return new Vec3(this.x * other.x, this.y * other.y, this.z * other.z);
  }

  componentDiv(other: Vec3): Vec3 {
    return new Vec3(this.x / other.x, this.y / other.y, this.z / other.z);
  }

  // Distance to another point
  distanceTo(other: Vec3): number {
    return this.sub(other).magnitude();
  }

  // Angle between vectors (radians)
  angleTo(other: Vec3): number {
    const crossMag = this.cross(other).magnitude();
    const dotVal = this.dot(other);
    return Math.atan2(crossMag, dotVal);
  }

  // To array
  toArray(): [number, number, number] {
    return [this.x, this.y, this.z];
  }

  // Clone
  clone(): Vec3 {
    return new Vec3(this.x, this.y, this.z);
  }

  // Static operations
  static dot(a: Vec3, b: Vec3): number {
    return a.dot(b);
  }

  static cross(a: Vec3, b: Vec3): Vec3 {
    return a.cross(b);
  }

  static distance(a: Vec3, b: Vec3): number {
    return a.distanceTo(b);
  }

  static angleBetween(a: Vec3, b: Vec3): number {
    return a.angleTo(b);
  }

  // Linear interpolation
  static lerp(a: Vec3, b: Vec3, t: number): Vec3 {
    return a.add(b.sub(a).scale(t));
  }
}
