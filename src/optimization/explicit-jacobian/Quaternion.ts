/**
 * Quaternion - Rotation quaternion for explicit gradient computations
 *
 * This is a plain number-based implementation (no automatic differentiation).
 * Used with hand-coded Jacobians generated by gradient-script.
 */

import { Vec3 } from './Vec3';

export class Quat {
  constructor(
    public readonly w: number,
    public readonly x: number,
    public readonly y: number,
    public readonly z: number
  ) {}

  // Static constructors
  static identity(): Quat {
    return new Quat(1, 0, 0, 0);
  }

  static fromAxisAngle(axis: Vec3, angleRadians: number): Quat {
    const halfAngle = angleRadians / 2;
    const s = Math.sin(halfAngle);
    const normalizedAxis = axis.normalize();
    return new Quat(
      Math.cos(halfAngle),
      normalizedAxis.x * s,
      normalizedAxis.y * s,
      normalizedAxis.z * s
    );
  }

  static fromEulerZYX(rx: number, ry: number, rz: number): Quat {
    const cx = Math.cos(rx / 2);
    const sx = Math.sin(rx / 2);
    const cy = Math.cos(ry / 2);
    const sy = Math.sin(ry / 2);
    const cz = Math.cos(rz / 2);
    const sz = Math.sin(rz / 2);

    return new Quat(
      cx * cy * cz + sx * sy * sz,
      sx * cy * cz - cx * sy * sz,
      cx * sy * cz + sx * cy * sz,
      cx * cy * sz - sx * sy * cz
    );
  }

  static fromArray(arr: [number, number, number, number]): Quat {
    return new Quat(arr[0], arr[1], arr[2], arr[3]);
  }

  // Squared magnitude
  sqrMagnitude(): number {
    return this.w * this.w + this.x * this.x + this.y * this.y + this.z * this.z;
  }

  // Magnitude
  magnitude(): number {
    return Math.sqrt(this.sqrMagnitude());
  }

  // Normalize
  normalize(): Quat {
    const mag = this.magnitude();
    if (mag < 1e-10) return Quat.identity();
    return new Quat(this.w / mag, this.x / mag, this.y / mag, this.z / mag);
  }

  // Conjugate (inverse for unit quaternions)
  conjugate(): Quat {
    return new Quat(this.w, -this.x, -this.y, -this.z);
  }

  // Multiply quaternions: this * other
  multiply(other: Quat): Quat {
    return new Quat(
      this.w * other.w - this.x * other.x - this.y * other.y - this.z * other.z,
      this.w * other.x + this.x * other.w + this.y * other.z - this.z * other.y,
      this.w * other.y - this.x * other.z + this.y * other.w + this.z * other.x,
      this.w * other.z + this.x * other.y - this.y * other.x + this.z * other.w
    );
  }

  /**
   * Rotate a vector by this quaternion: q * v * q*
   * Uses the optimized formula: v' = v + 2w(q × v) + 2(q × (q × v))
   * where q is the vector part (x, y, z) of the quaternion
   */
  rotate(v: Vec3): Vec3 {
    // Cross product: qVec × v
    const cx = this.y * v.z - this.z * v.y;
    const cy = this.z * v.x - this.x * v.z;
    const cz = this.x * v.y - this.y * v.x;

    // Double cross: qVec × (qVec × v)
    const dcx = this.y * cz - this.z * cy;
    const dcy = this.z * cx - this.x * cz;
    const dcz = this.x * cy - this.y * cx;

    return new Vec3(
      v.x + 2 * this.w * cx + 2 * dcx,
      v.y + 2 * this.w * cy + 2 * dcy,
      v.z + 2 * this.w * cz + 2 * dcz
    );
  }

  // To array [w, x, y, z]
  toArray(): [number, number, number, number] {
    return [this.w, this.x, this.y, this.z];
  }

  // Clone
  clone(): Quat {
    return new Quat(this.w, this.x, this.y, this.z);
  }

  // Spherical linear interpolation
  static slerp(a: Quat, b: Quat, t: number): Quat {
    let dot = a.w * b.w + a.x * b.x + a.y * b.y + a.z * b.z;

    // If dot < 0, negate one to take shorter path
    let bw = b.w, bx = b.x, by = b.y, bz = b.z;
    if (dot < 0) {
      dot = -dot;
      bw = -bw; bx = -bx; by = -by; bz = -bz;
    }

    // If very close, use linear interpolation
    if (dot > 0.9995) {
      return new Quat(
        a.w + t * (bw - a.w),
        a.x + t * (bx - a.x),
        a.y + t * (by - a.y),
        a.z + t * (bz - a.z)
      ).normalize();
    }

    const theta0 = Math.acos(dot);
    const theta = theta0 * t;
    const sinTheta = Math.sin(theta);
    const sinTheta0 = Math.sin(theta0);

    const s0 = Math.cos(theta) - dot * sinTheta / sinTheta0;
    const s1 = sinTheta / sinTheta0;

    return new Quat(
      s0 * a.w + s1 * bw,
      s0 * a.x + s1 * bx,
      s0 * a.y + s1 * by,
      s0 * a.z + s1 * bz
    );
  }
}
