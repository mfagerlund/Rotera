"""glTF 2.0 exporter for Pictorigo projects."""

import json
import numpy as np
from typing import Dict, List, Any, Optional
from pathlib import Path

from ..models.project import Project
from .converters import world_to_gltf_transform


class GLTFExporter:
    """Export Pictorigo projects to glTF 2.0 format."""

    def __init__(self):
        """Initialize the glTF exporter."""
        self.gltf_data = self._create_base_gltf()

    def _create_base_gltf(self) -> Dict[str, Any]:
        """Create the base glTF document structure."""
        return {
            "asset": {
                "version": "2.0",
                "generator": "Pictorigo 0.1.0",
                "copyright": "Generated by Pictorigo"
            },
            "scene": 0,
            "scenes": [
                {
                    "name": "Pictorigo Scene",
                    "nodes": []
                }
            ],
            "nodes": [],
            "cameras": [],
            "meshes": [],
            "accessors": [],
            "bufferViews": [],
            "buffers": []
        }

    def export_project(self, project: Project, include_meshes: bool = False) -> Dict[str, Any]:
        """
        Export a project to glTF format.

        Args:
            project: Project to export
            include_meshes: Whether to include visualization meshes

        Returns:
            glTF JSON data
        """
        self.gltf_data = self._create_base_gltf()

        # Convert world points to nodes
        self._export_world_points(project)

        # Convert cameras to glTF cameras and nodes
        self._export_cameras(project)

        # Optionally add visualization meshes
        if include_meshes:
            self._export_visualization_meshes(project)

        return self.gltf_data

    def _export_world_points(self, project: Project) -> None:
        """Export world points as empty nodes."""
        for wp_id, wp in project.world_points.items():
            if wp.xyz is None:
                continue

            # Convert coordinates to glTF coordinate system (Y-up, right-handed)
            position = world_to_gltf_transform(np.array(wp.xyz))

            node = {
                "name": f"WorldPoint_{wp_id}",
                "translation": position.tolist(),
                "extensions": {
                    "PICTORIGO_world_point": {
                        "id": wp_id,
                        "type": "world_point"
                    }
                }
            }

            node_index = len(self.gltf_data["nodes"])
            self.gltf_data["nodes"].append(node)
            self.gltf_data["scenes"][0]["nodes"].append(node_index)

    def _export_cameras(self, project: Project) -> None:
        """Export cameras with correct perspective and transforms."""
        for cam_id, camera in project.cameras.items():
            # Create glTF perspective camera
            fx, fy, cx, cy = camera.K[:4]

            # Get associated image for aspect ratio
            if cam_id in project.images:
                image = project.images[cam_id]
                aspect_ratio = image.width / image.height
            else:
                aspect_ratio = 1.0

            # Calculate field of view
            fov_y = 2 * np.arctan(cy / fy)

            gltf_camera = {
                "type": "perspective",
                "perspective": {
                    "aspectRatio": aspect_ratio,
                    "yfov": float(fov_y),
                    "znear": 0.1,
                    "zfar": 1000.0
                },
                "name": f"Camera_{cam_id}"
            }

            camera_index = len(self.gltf_data["cameras"])
            self.gltf_data["cameras"].append(gltf_camera)

            # Create camera node with transform
            R = np.array(camera.R).reshape(3)
            t = np.array(camera.t)

            # Convert camera pose to glTF coordinate system
            transform_matrix = self._camera_to_gltf_transform(R, t)

            camera_node = {
                "name": f"CameraNode_{cam_id}",
                "camera": camera_index,
                "matrix": transform_matrix.flatten().tolist(),
                "extensions": {
                    "PICTORIGO_camera": {
                        "id": cam_id,
                        "type": "camera",
                        "intrinsics": camera.K,
                        "image_id": camera.image_id
                    }
                }
            }

            node_index = len(self.gltf_data["nodes"])
            self.gltf_data["nodes"].append(camera_node)
            self.gltf_data["scenes"][0]["nodes"].append(node_index)

    def _camera_to_gltf_transform(self, R: np.ndarray, t: np.ndarray) -> np.ndarray:
        """Convert camera pose to glTF 4x4 transform matrix."""
        from ..math.se3 import se3_exp

        # Convert axis-angle to rotation matrix
        R_matrix, _ = se3_exp(np.concatenate([R, [0, 0, 0]]))

        # Convert to glTF coordinate system (Y-up, camera looks down -Z)
        # Pictorigo: Z-forward, Y-up, X-right
        # glTF: -Z-forward, Y-up, X-right
        coord_transform = np.array([
            [1, 0, 0],
            [0, 1, 0],
            [0, 0, -1]
        ])

        R_gltf = coord_transform @ R_matrix @ coord_transform.T
        t_gltf = world_to_gltf_transform(t)

        # Create 4x4 transform matrix
        transform = np.eye(4)
        transform[:3, :3] = R_gltf
        transform[:3, 3] = t_gltf

        return transform

    def _export_visualization_meshes(self, project: Project) -> None:
        """Export optional visualization meshes for world points."""
        # Create a simple sphere mesh for world points
        vertices, indices = self._create_sphere_mesh(radius=0.05, subdivisions=2)

        # Add mesh data to glTF
        self._add_mesh_to_gltf("WorldPointSphere", vertices, indices)

        # Create mesh instances for each world point
        mesh_index = len(self.gltf_data["meshes"]) - 1

        for wp_id, wp in project.world_points.items():
            if wp.xyz is None:
                continue

            position = world_to_gltf_transform(np.array(wp.xyz))

            mesh_node = {
                "name": f"WorldPointMesh_{wp_id}",
                "mesh": mesh_index,
                "translation": position.tolist(),
                "scale": [0.1, 0.1, 0.1]  # Small spheres
            }

            node_index = len(self.gltf_data["nodes"])
            self.gltf_data["nodes"].append(mesh_node)
            self.gltf_data["scenes"][0]["nodes"].append(node_index)

    def _create_sphere_mesh(self, radius: float = 1.0, subdivisions: int = 2) -> tuple[np.ndarray, np.ndarray]:
        """Create a simple sphere mesh."""
        # Simple icosphere generation
        vertices = []
        indices = []

        # Golden ratio
        phi = (1.0 + np.sqrt(5.0)) / 2.0

        # Initial vertices of icosahedron
        initial_verts = [
            [-1,  phi,  0], [ 1,  phi,  0], [-1, -phi,  0], [ 1, -phi,  0],
            [ 0, -1,  phi], [ 0,  1,  phi], [ 0, -1, -phi], [ 0,  1, -phi],
            [ phi,  0, -1], [ phi,  0,  1], [-phi,  0, -1], [-phi,  0,  1]
        ]

        # Normalize and scale
        for v in initial_verts:
            norm = np.linalg.norm(v)
            vertices.append([x * radius / norm for x in v])

        # Simple triangulation (basic icosahedron faces)
        faces = [
            [0,11,5], [0,5,1], [0,1,7], [0,7,10], [0,10,11],
            [1,5,9], [5,11,4], [11,10,2], [10,7,6], [7,1,8],
            [3,9,4], [3,4,2], [3,2,6], [3,6,8], [3,8,9],
            [4,9,5], [2,4,11], [6,2,10], [8,6,7], [9,8,1]
        ]

        return np.array(vertices, dtype=np.float32), np.array(faces, dtype=np.uint16)

    def _add_mesh_to_gltf(self, name: str, vertices: np.ndarray, indices: np.ndarray) -> None:
        """Add mesh data to glTF buffers and create mesh object."""
        # Add vertex buffer
        vertex_buffer = vertices.tobytes()
        buffer_index = len(self.gltf_data["buffers"])

        self.gltf_data["buffers"].append({
            "byteLength": len(vertex_buffer),
            "uri": f"data:application/octet-stream;base64,{self._encode_base64(vertex_buffer)}"
        })

        # Add vertex buffer view
        vertex_buffer_view = {
            "buffer": buffer_index,
            "byteOffset": 0,
            "byteLength": len(vertex_buffer),
            "target": 34962  # ARRAY_BUFFER
        }
        vertex_buffer_view_index = len(self.gltf_data["bufferViews"])
        self.gltf_data["bufferViews"].append(vertex_buffer_view)

        # Add position accessor
        position_accessor = {
            "bufferView": vertex_buffer_view_index,
            "byteOffset": 0,
            "componentType": 5126,  # FLOAT
            "count": len(vertices),
            "type": "VEC3",
            "min": vertices.min(axis=0).tolist(),
            "max": vertices.max(axis=0).tolist()
        }
        position_accessor_index = len(self.gltf_data["accessors"])
        self.gltf_data["accessors"].append(position_accessor)

        # Add index buffer
        index_buffer = indices.tobytes()
        index_buffer_index = len(self.gltf_data["buffers"])

        self.gltf_data["buffers"].append({
            "byteLength": len(index_buffer),
            "uri": f"data:application/octet-stream;base64,{self._encode_base64(index_buffer)}"
        })

        # Add index buffer view
        index_buffer_view = {
            "buffer": index_buffer_index,
            "byteOffset": 0,
            "byteLength": len(index_buffer),
            "target": 34963  # ELEMENT_ARRAY_BUFFER
        }
        index_buffer_view_index = len(self.gltf_data["bufferViews"])
        self.gltf_data["bufferViews"].append(index_buffer_view)

        # Add index accessor
        index_accessor = {
            "bufferView": index_buffer_view_index,
            "byteOffset": 0,
            "componentType": 5123,  # UNSIGNED_SHORT
            "count": len(indices.flatten()),
            "type": "SCALAR"
        }
        index_accessor_index = len(self.gltf_data["accessors"])
        self.gltf_data["accessors"].append(index_accessor)

        # Create mesh
        mesh = {
            "name": name,
            "primitives": [
                {
                    "attributes": {
                        "POSITION": position_accessor_index
                    },
                    "indices": index_accessor_index,
                    "mode": 4  # TRIANGLES
                }
            ]
        }

        self.gltf_data["meshes"].append(mesh)

    def _encode_base64(self, data: bytes) -> str:
        """Encode binary data as base64 string."""
        import base64
        return base64.b64encode(data).decode('ascii')

    def save_to_file(self, filepath: Path, project: Project, include_meshes: bool = False) -> None:
        """Save project as glTF file."""
        gltf_data = self.export_project(project, include_meshes)

        with open(filepath, 'w') as f:
            json.dump(gltf_data, f, indent=2)

    def save_to_string(self, project: Project, include_meshes: bool = False) -> str:
        """Export project as glTF JSON string."""
        gltf_data = self.export_project(project, include_meshes)
        return json.dumps(gltf_data, indent=2)